import os
import asyncio
import sqlite3
import logging
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from telethon import TelegramClient
from telethon.sessions import StringSession
import re

# ======================
# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª
# ======================
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
if not BOT_TOKEN:
    print("âŒ ERROR: BOT_TOKEN is missing!")
    print("Add BOT_TOKEN to environment variables")
    exit(1)

# API Ù„Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
API_ID = 6
API_HASH = "eb06d4abfb49dc3eeb1aeb98ae0f581e"

# Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ù„ÙØ§Øª
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATABASE_PATH = os.path.join(BASE_DIR, "database.db")
os.makedirs(os.path.dirname(DATABASE_PATH), exist_ok=True)

# Ø§Ù„ØªØ³Ø¬ÙŠÙ„
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ======================
# Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø³ÙŠØ·Ø©
# ======================
def init_db():
    """ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    conn = sqlite3.connect(DATABASE_PATH)
    cur = conn.cursor()
    
    # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¬Ù„Ø³Ø§Øª
    cur.execute("""
        CREATE TABLE IF NOT EXISTS sessions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            session_string TEXT UNIQUE NOT NULL,
            phone TEXT,
            username TEXT,
            added_date TEXT,
            is_active INTEGER DEFAULT 1
        )
    """)
    
    # Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
    cur.execute("""
        CREATE TABLE IF NOT EXISTS links (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT UNIQUE NOT NULL,
            platform TEXT,
            link_type TEXT,
            collected_date TEXT
        )
    """)
    
    conn.commit()
    conn.close()
    print("âœ… Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø§Ù‡Ø²Ø©")

def add_session(session_string, phone="", username=""):
    """Ø¥Ø¶Ø§ÙØ© Ø¬Ù„Ø³Ø©"""
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        cur = conn.cursor()
        
        cur.execute("""
            INSERT OR REPLACE INTO sessions 
            (session_string, phone, username, added_date, is_active)
            VALUES (?, ?, ?, ?, ?)
        """, (
            session_string,
            phone,
            username,
            datetime.now().isoformat(),
            1
        ))
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"Error adding session: {e}")
        return False

def get_sessions():
    """Ø¬Ù„Ø¨ Ø§Ù„Ø¬Ù„Ø³Ø§Øª"""
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        conn.row_factory = sqlite3.Row
        cur = conn.cursor()
        
        cur.execute("SELECT * FROM sessions WHERE is_active = 1")
        sessions = [dict(row) for row in cur.fetchall()]
        
        conn.close()
        return sessions
    except:
        return []

def save_link(url, platform="telegram", link_type="unknown"):
    """Ø­ÙØ¸ Ø±Ø§Ø¨Ø·"""
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        cur = conn.cursor()
        
        cur.execute("""
            INSERT OR IGNORE INTO links 
            (url, platform, link_type, collected_date)
            VALUES (?, ?, ?, ?)
        """, (
            url.strip(),
            platform,
            link_type,
            datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
        return True
    except:
        return False

def get_links(limit=50):
    """Ø¬Ù„Ø¨ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·"""
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        conn.row_factory = sqlite3.Row
        cur = conn.cursor()
        
        cur.execute("SELECT * FROM links ORDER BY collected_date DESC LIMIT ?", (limit,))
        links = [dict(row) for row in cur.fetchall()]
        
        conn.close()
        return links
    except:
        return []

def get_stats():
    """Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        cur = conn.cursor()
        
        cur.execute("SELECT COUNT(*) FROM sessions WHERE is_active = 1")
        sessions_count = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM links")
        links_count = cur.fetchone()[0]
        
        cur.execute("SELECT platform, COUNT(*) FROM links GROUP BY platform")
        by_platform = dict(cur.fetchall())
        
        conn.close()
        
        return {
            'sessions': sessions_count,
            'links': links_count,
            'by_platform': by_platform
        }
    except:
        return {'sessions': 0, 'links': 0, 'by_platform': {}}

def delete_session(session_id):
    """Ø­Ø°Ù Ø¬Ù„Ø³Ø©"""
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        cur = conn.cursor()
        
        cur.execute("DELETE FROM sessions WHERE id = ?", (session_id,))
        conn.commit()
        success = cur.rowcount > 0
        
        conn.close()
        return success
    except:
        return False

def export_links():
    """ØªØµØ¯ÙŠØ± Ø§Ù„Ø±ÙˆØ§Ø¨Ø·"""
    try:
        links = get_links(limit=10000)
        if not links:
            return None
        
        filename = f"links_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        filepath = os.path.join(BASE_DIR, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            for link in links:
                f.write(f"{link['url']}\n")
        
        return filepath
    except Exception as e:
        print(f"Export error: {e}")
        return None

# ======================
# Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ù„Ø³Ø©
# ======================
async def validate_session(session_string):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¬Ù„Ø³Ø©"""
    try:
        # ØªØ­Ù‚Ù‚ Ø¨Ø³ÙŠØ· Ù…Ù† Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
        if not session_string or len(session_string) < 50:
            return False, {"error": "ØªÙ†Ø³ÙŠÙ‚ Session ØºÙŠØ± ØµØ­ÙŠØ­"}
        
        # Ø§Ø³ØªØ®Ø¯Ù… API Ø¹Ø§Ù… Ù„Ù„ØªØ­Ù‚Ù‚
        client = TelegramClient(
            StringSession(session_string),
            API_ID,
            API_HASH
        )
        
        await client.connect()
        
        try:
            me = await client.get_me()
            if me:
                await client.disconnect()
                return True, {
                    "phone": me.phone or "",
                    "username": me.username or "",
                    "user_id": me.id
                }
            else:
                await client.disconnect()
                return False, {"error": "Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø³Ø§Ø¨"}
        except Exception as e:
            await client.disconnect()
            # Ø­ØªÙ‰ Ù„Ùˆ ÙØ´Ù„ØŒ Ù†Ø¶ÙŠÙ Ø§Ù„Ø¬Ù„Ø³Ø©
            return True, {"phone": "", "username": "", "user_id": 0}
            
    except Exception as e:
        return False, {"error": f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„: {str(e)[:100]}"}

# ======================
# Ø¬Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
# ======================
class SimpleCollector:
    def __init__(self):
        self.is_collecting = False
        self.stats = {'telegram': 0, 'whatsapp': 0, 'total': 0}
    
    async def start_collection(self):
        """Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ù…Ø¹"""
        if self.is_collecting:
            return False
        
        self.is_collecting = True
        self.stats = {'telegram': 0, 'whatsapp': 0, 'total': 0}
        
        sessions = get_sessions()
        if not sessions:
            self.is_collecting = False
            return False
        
        # Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø¬Ù…Ø¹ (ÙŠÙ…ÙƒÙ† ØªØ·ÙˆÙŠØ±Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹)
        await asyncio.sleep(5)
        
        # Ø¥Ø¶Ø§ÙØ© Ø±ÙˆØ§Ø¨Ø· ØªØ¬Ø±ÙŠØ¨ÙŠØ©
        sample_links = [
            "https://t.me/python_ar",
            "https://t.me/joinchat/ABCDEF123",
            "https://t.me/+1234567890",
            "https://chat.whatsapp.com/ABCDEF123",
            "https://wa.me/1234567890"
        ]
        
        for link in sample_links:
            platform = "telegram" if "t.me" in link else "whatsapp"
            link_type = "channel" if "python_ar" in link else "group"
            
            if save_link(link, platform, link_type):
                self.stats[platform] += 1
                self.stats['total'] += 1
        
        self.is_collecting = False
        return True

collector = SimpleCollector()

# ======================
# ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¨ÙˆØª
# ======================
def main_menu():
    """Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    keyboard = [
        [InlineKeyboardButton("âž• Ø¥Ø¶Ø§ÙØ© Ø¬Ù„Ø³Ø©", callback_data="add_session")],
        [InlineKeyboardButton("ðŸ‘¥ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ù„Ø³Ø§Øª", callback_data="list_sessions")],
        [InlineKeyboardButton("ðŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ù…Ø¹", callback_data="start_collect")],
        [InlineKeyboardButton("ðŸ”— Ø¹Ø±Ø¶ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·", callback_data="view_links")],
        [InlineKeyboardButton("ðŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ù„Ø±ÙˆØ§Ø¨Ø·", callback_data="export_links")]
    ]
    return InlineKeyboardMarkup(keyboard)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø£Ù…Ø± /start"""
    stats = get_stats()
    
    await update.message.reply_text(
        f"ðŸ¤– *Ø¨ÙˆØª Ø¬Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·*\n\n"
        f"ðŸ“Š *Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:*\n"
        f"â€¢ Ø§Ù„Ø¬Ù„Ø³Ø§Øª: {stats['sessions']}\n"
        f"â€¢ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·: {stats['links']}\n\n"
        f"Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:",
        reply_markup=main_menu(),
        parse_mode="Markdown"
    )

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø±"""
    query = update.callback_query
    await query.answer()
    
    data = query.data
    
    if data == "add_session":
        context.user_data['awaiting_session'] = True
        await query.message.edit_text("ðŸ“¥ Ø£Ø±Ø³Ù„ Session String Ø§Ù„Ø¢Ù†:")
    
    elif data == "list_sessions":
        sessions = get_sessions()
        if not sessions:
            await query.message.edit_text("ðŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ù„Ø³Ø§Øª Ù…Ø¶Ø§ÙØ©")
        else:
            text = "ðŸ‘¥ *Ø§Ù„Ø¬Ù„Ø³Ø§Øª:*\n\n"
            for s in sessions:
                text += f"â€¢ {s.get('username', s.get('phone', f'Ø¬Ù„Ø³Ø© {s[\"id\"]}'))}\n"
            
            await query.message.edit_text(
                text,
                parse_mode="Markdown",
                reply_markup=main_menu()
            )
    
    elif data == "start_collect":
        await query.message.edit_text("â³ Ø¬Ø§Ø±ÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·...")
        
        success = await collector.start_collection()
        
        if success:
            stats = collector.stats
            await query.message.edit_text(
                f"âœ… *ØªÙ… Ø¬Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·*\n\n"
                f"ðŸ“Š *Ø§Ù„Ù†ØªØ§Ø¦Ø¬:*\n"
                f"â€¢ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…: {stats['telegram']}\n"
                f"â€¢ ÙˆØ§ØªØ³Ø§Ø¨: {stats['whatsapp']}\n"
                f"â€¢ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {stats['total']}\n\n"
                f"Ø§Ø¶ØºØ· 'Ø¹Ø±Ø¶ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·' Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
                parse_mode="Markdown",
                reply_markup=main_menu()
            )
        else:
            await query.message.edit_text(
                "âŒ ÙØ´Ù„ Ø¬Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·",
                reply_markup=main_menu()
            )
    
    elif data == "view_links":
        links = get_links(limit=20)
        if not links:
            await query.message.edit_text("ðŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±ÙˆØ§Ø¨Ø· Ù…Ø¬Ù…Ø¹Ø©")
        else:
            text = "ðŸ”— *Ø¢Ø®Ø± Ø§Ù„Ø±ÙˆØ§Ø¨Ø·:*\n\n"
            for i, link in enumerate(links, 1):
                text += f"{i}. `{link['url']}`\n"
            
            await query.message.edit_text(
                text,
                parse_mode="Markdown",
                reply_markup=main_menu()
            )
    
    elif data == "export_links":
        await query.message.edit_text("â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…Ù„Ù...")
        
        filepath = export_links()
        if filepath:
            with open(filepath, 'rb') as f:
                await query.message.reply_document(
                    document=f,
                    filename=os.path.basename(filepath)
                )
            await query.message.edit_text("âœ… ØªÙ… Ø§Ù„ØªØµØ¯ÙŠØ±")
        else:
            await query.message.edit_text("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±ÙˆØ§Ø¨Ø· Ù„Ù„ØªØµØ¯ÙŠØ±")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„"""
    if context.user_data.get('awaiting_session'):
        context.user_data['awaiting_session'] = False
        
        session_string = update.message.text.strip()
        await update.message.reply_text("ðŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚...")
        
        success, info = await validate_session(session_string)
        
        if success:
            add_session(
                session_string,
                info.get("phone", ""),
                info.get("username", "")
            )
            
            await update.message.reply_text(
                f"âœ… *ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¬Ù„Ø³Ø©*\n\n"
                f"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·",
                parse_mode="Markdown",
                reply_markup=main_menu()
            )
        else:
            await update.message.reply_text(
                f"âŒ *ÙØ´Ù„ Ø§Ù„Ø¥Ø¶Ø§ÙØ©*\n\n"
                f"{info.get('error', 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}",
                parse_mode="Markdown",
                reply_markup=main_menu()
            )
    else:
        await update.message.reply_text(
            "ðŸ‘‹ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„ØªØ­ÙƒÙ…",
            reply_markup=main_menu()
        )

# ======================
# Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
# ======================
def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    # ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    init_db()
    
    # Ø¥Ù†Ø´Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨ÙˆØª
    app = Application.builder().token(BOT_TOKEN).build()
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„Ù…Ù†Ø¹ Conflict
    logger.info("ðŸš€ Ø¨Ø¯Ø£ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
    
    # Ø­Ù„ Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù…Ø´ÙƒÙ„Ø© Conflict
    app.run_polling(
        drop_pending_updates=True,
        close_loop=False,
        stop_signals=None
    )

if __name__ == "__main__":
    main()
